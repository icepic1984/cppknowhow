* C++ Know-How
** Declaration vs Definition
 We’ll use the term symbol to refer to any kind of “code entity” that a
 linker works with, i.e. variables, functions and classes/structs.

 A *declaration* tells the compiler about the existence of a certain
 symbol and makes it possible to refer to that symbol everywhere where
 the explicit memory address or required storage of that symbol is not
 required. A *definition* tells the compiler what the body of a
 function contains or how much memory it must allocate for a variable.

 Example for function declaration and definition
 #+begin_src cpp 
   int f();             // declaration
   int f() {return 42;} // definition

   int main() {}
 #+end_src
 
 Example for variable declaration and definition
 #+begin_src cpp 
   int x;             // definition
   int y = 42;        // definition and initialization
   extern int u;      // declaration 
   extern int v = 42; // definition
   int main() {}
 #+end_src

 #+RESULTS:

*** One Definition Rule (ODR)

  + In any translation unit, a template, type, function, or object can
    have no more than one definition. Some of these can have any number
    of declarations. A definition provides an instance.

  + In the entire program, an object or non-inline function cannot have
    more than one definition; if an object or function is used, it must
    have exactly one definition. You can declare an object or function
    that is never used, in which case you don't have to provide a
    definition. In no event can there be more than one definition.

  + Some things, like types, templates, and extern inline functions, can
    be defined in more than one translation unit. For a given entity,
    each definition must be the same. Non-extern objects and functions
    in different translation units are different entities, even if their
    names and types are the same.

  Some violations of the ODR must be diagnosed by the compiler. Other
  violations, particularly those that span translation units, are not
  required to be diagnosed.[1]
** Argument vs Parameter
 *Argument* is the value/variable/reference being passed in, *parameter*
 is the receiving variable used w/in the function/block.
** Linkage
 A *translation unit* refers to an implementation (.c/.cpp) file and
 all header (.h/.hpp) files it includes. If an object or function
 inside such a translation unit has *internal linkage*, then that
 specific symbol is only visible to the linker within that translation
 unit. If an object or function has *external linkage*, the linker can
 also see it when processing other translation units. The ~static~
 keyword, when used in the global namespace, forces a symbol to have
 internal linkage. The ~extern~ keyword results in a symbol having
 external linkage. Anonymous namespaces are another way to declare one
 or more symbols to have internal linkage.

 The compiler defaults the linkage of symbols such that:

 + Non-const global variables have external linkage by default
 + Const global variables have internal linkage by default
 + Functions have external linkage by default

** Expressions
 An expression is a sequence of operators and their operands, that
 specifies a computation. Expression evaluation may produce a result
 and may generate side-effects.

*** Value categories
  Each C++ expression (an operator with its operands, a literal, a
  variable name, etc.) is characterized by two independent properties: a
  type and a value category. Each expression has some non-reference
  type, and each expression belongs to exactly one of the three primary
  value categories: prvalue, xvalue, lvalue, defined as follows:

  #+begin_src dot :file value_type.png :exports none
  digraph G {
      nodesep=0.3;
      ranksep=0.2;
      margin=0.1;
      node [shape=circle];
      edge [arrowsize=0.8];
      Expression -> glvalue
      Expression -> rvalue
      glvalue -> lvalue
      glvalue -> xvalue
      rvalue -> xvalue
      rvalue -> prvalue
  }
  #+end_src

  #+RESULTS:
  [[file:value_type.png]]

**** lvalue   
   An lvalue (so called, historically, because lvalues could appear on
   the left-hand side of an assignment expression) designates a
   function or an object.

   Example: If E is an expression of pointer type, then
   *E is an lvalue expression referring to the object or function to
   which E points. As another example, the result of calling a function
   whose return type is an lvalue reference is an lvalue. 

   Non-formal definition:
   An lvalue (locator value) represents an object that occupies some
   identifiable location in memory (i.e. has an address).

**** xvalue
   An xvalue (an “eXpiring” value) also refers to an object, usually near
   the end of its lifetime (so that its resources may be moved, for
   example). An xvalue is the result of certain kinds of expressions
   involving rvalue references.

   Example: The result of calling a function whose return type is an
   rvalue reference is an xvalue. 

   #+begin_src cpp :includes <string>
     std::string a;
     std::string &b = a;

     a;            // lvalue       
     b;            // lvalue
     std::move(a); // This expression is a xvalue
   #+end_src

   #+RESULTS:
**** prvalue
   A prvalue (“pure” rvalue) is an rvalue that is not an xvalue. 

   Example: The result of calling a function whose return type is not a
   reference is a prvalue. The value of a literal such as 12, 7.3e5, or
   true is also a prvalue. 
   A prvalue (“pure” rvalue) is an rvalue that is not an xvalue. 

   Example: The result of calling a function whose return type is not a
   reference is a prvalue. The value of a literal such as 12, 7.3e5, or
   true is also a prvalue. 

**** gvalue
   A glvalue (“generalized” lvalue) is an lvalue or an xvalue.
**** rvalue
   An rvalue (so called, historically, because rvalues could appear on
   the right-hand side of an assignment expressions) is an xvalue, a
   temporary object (12.2) or subobject thereof, or a value that is not
   associated with an object.
** Special member functions
 See [[https://www.youtube.com/watch?v=vLinb2fgkHk][Howard Hinnart: All you need to know about move semantics]] ([[https://de.slideshare.net/ripplelabs/howard-hinnant-accu2014][Slides]])

 Speical members are those menber function that the compiler can be
 asked to automatically generate code for.
 + Default constructor ~X();~
 + Destoructor ~\~X();~
 + Copy constructor ~X(const X& );~
 + Copy assignment ~X& operator=(const X&);~
 + Move constructor ~X(X&&);~
 + Move assignment ~X& operator=(X&&);~

 Special member functions can be:
 + not declared
 + implicitly declared (defaulted or deleted by the compiler)
 + user declared (deleted, defaulted, user-defined)

 What does user declared means?
 #+begin_src cpp 
   struct X 
   {
       X() {}        // user-declared
       X();          // user-declared but compiler generates definition
       X() = default;// user-declared 
       X() = delete; // user declared (deleted member functions participate
       // in overload resolution
   };
 #+end_src
  
 Generation of special member functions:
|---------------------+----------------------+---------------+-----------------+-----------------+------------------+-----------------|
|                     | *Compiler generated* |               |                 |                 |                  |                 |
|---------------------+----------------------+---------------+-----------------+-----------------+------------------+-----------------|
| *User declared*     | default constructor  | destructor    | copy destructor | copy assignment | move constructor | move assignment |
|---------------------+----------------------+---------------+-----------------+-----------------+------------------+-----------------|
| nothing             | defaulted            | defaulted     | defaulted       | defaulted       | defaulted        | defaulted       |
| any constructor     | not declared         | defaulted     | defaulted       | defaulted       | defaulted        | defaulted       |
| default constructor | user declared        | defaulted     | defaulted       | defaulted       | defaulted        | defaulted       |
| destructor          | defaulted            | user declared | defaulted*      | defaulted*      | not declared     | not declared    |
| copy constructor    | not declared         | defaulted     | user declared   | defaulted*      | not declared     | not declared    |
| copy assignment     | defaulted            | defaulted     | defaulted*      | user declared   | not declared     | not declared    |
| move constructor    | not declared         | defaulted     | deleted         | deleted         | user declared    | not declared    |
| move assignment     | defaulted            | defaulted     | deleted         | deleted         | not declared     | user declared   |
|---------------------+----------------------+---------------+-----------------+-----------------+------------------+-----------------|
| * = deprecated      |                      |               |                 |                 |                  |                 |
 
** Operator Precedence
 |------------+---------------+---------------------------+---------------|
 | Precedence | Operator      | Description               | Associativity |
 |------------+---------------+---------------------------+---------------|
 |          1 | ::            | Scope resolution          | Left-to-right |
 |------------+---------------+---------------------------+---------------|
 |          2 | a++, a--      | Postfix inc/dec           | Left-to-right |
 |            | type()        | Functional cast           |               |
 |            | a()           | Functional call           |               |
 |            | a[]           | Subscript                 |               |
 |            | . ->          | Member access             |               |
 |------------+---------------+---------------------------+---------------|
 |          3 | ++a, --a      | Prefix inc/dec            | Right-to-left |
 |            | +a, -a        | Unary plus/minus          |               |
 |            | ! ~           | Logical Not, Bitwise Not  |               |
 |            | (type)        | C-style cast              |               |
 |            | *a            | Dereference               |               |
 |            | &a            | Address-of                |               |
 |            | sizeof        | Size-of                   |               |
 |            | new           | Dynamic memory allocation |               |
 |            | delete        | Dynamic memory allocation |               |
 |------------+---------------+---------------------------+---------------|
 |          4 | .*, ->*       | Pointer-to-member         | Left-to-right |
 |------------+---------------+---------------------------+---------------|
 |          5 | a*b, a/b, a%b | Mul, Div, Modul           | Left-to-right |
 |------------+---------------+---------------------------+---------------|
 |          6 | a+b, a-b      | Add, Sub                  | Left-to-right |
 |------------+---------------+---------------------------+---------------|
 |          7 | <<, >>        | Bitwise left shift, right | Left-to-right |
 |------------+---------------+---------------------------+---------------|
 |          8 | <=>           | Three-way comparison      | Left-to-right |
 |------------+---------------+---------------------------+---------------|
 |          9 | < <=          | Relation operators        | Left-to-right |
 |            | > >=          | Relation operators        | Left-to-right |
 |------------+---------------+---------------------------+---------------|
 |         10 | == !=         | Relation operators        | Left-to-right |
 |------------+---------------+---------------------------+---------------|
 |         11 | a&b           | Bitwise and               | Left-to-right |
 |------------+---------------+---------------------------+---------------|
 |         12 | a^b           | Bitwise xor               | Left-to-right |
 |------------+---------------+---------------------------+---------------|
 |         13 | a OR b        | Bitwise or                | Left-to-right |
 |------------+---------------+---------------------------+---------------|
 |         14 | &&            | Logical and               | Left-to-right |
 |------------+---------------+---------------------------+---------------|
 |         15 |               | Logical or                | Left-to-right |
 |------------+---------------+---------------------------+---------------|
 |         16 | a?b:c         | Ternary operator          | Right-to-left |
 |            | throw         |                           |               |
 |            | =             |                           |               |
 |            | +=, -=        |                           |               |
 |            | *=, /=, %=    |                           |               |
 |            | <<=, >>=      |                           |               |
 |            | &=, ^=,       |                           |               |
 |------------+---------------+---------------------------+---------------|
 |         17 | ,             | Comma Operator            | Left-to-right |

 Example bit operator

 #+begin_src cpp :includes <iostream>
 std::cout << "4 & 2   << 1: " << (4 & 2 << 1) << std::endl;
 std::cout << "(4 & 2) << 1: " << ((4 & 2) << 1) << std::endl;
 #+end_src

 #+RESULTS:
 |  4 | & |  2 | << | 1: | 4 |
 | (4 | & | 2) | << | 1: | 0 |

** What happens when you call in function in c++?
   1) Name lookup
   2) Template Argument Deduction
   3) Overload Resolution
      + Overload Resoltion has rnules that select the desired overload
        by comparing the argument types agaist the parameter types.
        + Could i possible call this function?
        + Is this the best match?
   4) Access control
      + One of the last steps.
      + Once we pick a winner we decide if the allowed to call it.
   5) Virtual function
*** Name lookup
  + Unqualified name lookup
    
    For an unqualified name, that is a name that does not appear to
    the right of a scope resolution operator ::, name lookup examines
    the scopes as described below, until it finds at least one
    declaration of any kind, at which time the lookup stops and no
    further scopes are examined.
    
    See [[http://en.cppreference.com/w/cpp/language/unqualified_lookup][Link]]
  + Qualified name lookup
    
    A qualified name is a name that appears on the right hand side of
    the scope resolution operator :: (see also qualified identifiers).
  + Arguement dependent lookup 

    If you supply a function argument of class type, then to find the
    function name the compiler considers matching names in the
    namespace containing the argument's type.

    #+begin_src cpp :includes <iostream>
      namespace A { // Begin of namespace A

      struct B {}; 

      void foo(B x) {
          std::cout <<"foo(A)" << std::endl;
      }
      } // End of namespace A

      int main() {
          foo(A::B()); // ADL rule applies
      }

    #+end_src 
    
    Example where ADL leads to unexpected behaviour.
    
    #+begin_src cpp :includes <iostream>
      namespace A { // Begin of namespace A
      namespace B { // Begin of namespace B

      struct C {};

      void foo(C x) {std::cout << "A::B::C::foo()" << std::endl;} // Is called
      } // End of namespace B
      using B::C;
      void foo(C x) {std::cout << "A::C::foo()" << std::endl;} // Is not called

      } // End of namespace A

      int main() {
          A::C c;
          foo(c); // ADL only searches in the namespace in which the type was defined
      }

    #+end_src 

    #+RESULTS:
    : A::B::C::foo()

*** Template Arguement Deduction
    + Dropping const when function template takes parameter by value
      
      #+begin_src cpp
        template <typename T>
        void foo(T t) { t*=2; }; // const ist dropped

        template <typename T>
        void bar(const T t) {t*=2;}; 

        int main() {
            const int i = 0;
            foo(i);
            bar(i); // Does not compile
        }


      #+end_src

      #+RESULTS:

    + Template arguement deduction does not convert
      
      #+begin_src cpp 
        #include <iostream>
        #include <functional>
        template<typename T>
        void foo(T val, std::function<void (T)> f) {
            f(val);
        }

        // Identity template meta function
        template <typename T>
        struct Identity 
        {
            using type = T;
        };

        template <typename T>
        void bar(T val, typename Identity<std::function<void (T)>>::type f) {
            f(val);
        }

        int main() {
            std::function<void (int)> fxn = [] (int x) { std::cout << x << std::endl;};
            // foo(1234, [](int x) { std::cout << x << std::endl;}); Fails to compile
            foo(1234, fxn); // Ok because no conversion takes place
            bar(1234, [] (int x) { std::cout << x << std::endl;}); // Ok because type is deduced in Idenity metafunc and then converted
        }
      #+end_src

      #+RESULTS:
      | 1234 |
      | 1234 |

    + When template argument deduction fail, function is not added to
      overload resolution set
      
** Ideoms
*** Template based configuration
    See [[https://youtu.be/NH1Tta7purM?t=1003][Link]]
*** Type Erasue
    See [[https://quuxplusone.github.io/blog/2020/11/24/type-erased-printable/][Link]]
**** UniquePrintable (owning, value-semantic, move-only)
  #+begin_src cpp
    #include <memory>
    #include <ostream>

    struct PrintableBase {
        virtual void print(std::ostream& os) const = 0;
        virtual ~PrintableBase() = default;
    };

    template<class T>
    struct PrintableImpl : PrintableBase {
        T t_;
        explicit PrintableImpl(T t) : t_(std::move(t)) {}
        void print(std::ostream& os) const override { os << t_; }
    };

    class UniquePrintable {
        std::unique_ptr<PrintableBase> p_;
    public:
        template<class T>
        UniquePrintable(T t) : p_(std::make_unique<PrintableImpl<T>>(std::move(t))) { }

        friend std::ostream& operator<<(std::ostream& os, const UniquePrintable& self) {
            self.p_->print(os);
            return os;
        }
    };

    #include <iostream>

    void printit(UniquePrintable p) {
        std::cout << "The printable thing was: " << p << "." << std::endl;
    }

    int main() {
        printit(42);
        printit("hello world");
    }
  #+end_src

**** PrintableRef (non-owning, reference-semantic, trivially copyable)
    #+begin_src cpp
      #include <ostream>

      class PrintableRef {
          const void *data_;
          void (*print_)(std::ostream&, const void *);
      public:
          template<class T>
          PrintableRef(const T& t) : data_(&t), print_([](std::ostream& os, const void *data) {
              os << *(const T*)data;
          }) { }

          friend std::ostream& operator<<(std::ostream& os, const PrintableRef& self) {
              self.print_(os, self.data_);
              return os;
          }
      };

      #include <iostream>

      void printit(PrintableRef p) {
          std::cout << "The printable thing was: " << p << "." << std::endl;
      }

      int main() {
          printit(42);
          printit("hello world");
      }
    #+end_src

** Mixed stuff
*** Ref-Qualifiers
    See [[https://akrzemi1.wordpress.com/2014/06/02/ref-qualifiers/][Link]]
    
    Possible use-cases
    
    + To provide an optimized overload, for example to move a member
      out of a temporary object instead of having to copy it.
   
      #+begin_src cpp
      #include <iostream>
      template <typename T>
      struct wrapper {
          wrapper(T t) : m_value(std::move(t)){}

          T& value() & {
              std::cout << " T& value() &" << std::endl;
              return m_value;
          }
                        
          const T& value() const &  {
              std::cout << "const_T& value() &" << std::endl;
              return m_value;
          } 
      public:
                
          T&& value() && {
              std::cout << "T&& value() &&" << std::endl;
              return std::move(m_value);
          }
                
          T m_value;
      };

      int main(){
          wrapper<int> foo(10);
          const wrapper<int> bar = wrapper<int>(10);
          foo.value(); // Calls T& value() &
          bar.value(); // Calls const T& value()
          wrapper<int>(10).value(); // Calls T&& value() &&
      }
    #+end_src cpp

      #+RESULTS:
      | T&       | value() | &  |
      | const_T& | value() | &  |
      | T&&      | value() | && |
      
    + Prevent misuse of an API.
    
** Interpreting const expressions
 It modifies what precedes it, unless nothing precedes it. When no
 type precedes the const, you have to logically move it behind the
 first type.


 Examples:
 #+begin_src cpp 
   char const* buffer; // const modifies char
   char* const bufffer // const modifies *

   // Here the const to the right of the asterisk declares ptr to be
   // const: ptr can't be made to point to a different location, nor can
   // it be set to null. The const to the left of the asterisk says that
   // what ptr points to - the caracter stringj - is const, hence can't
   // be modified.
   //
   // Const pointer to a const object
   const char* const ptr;
   char const* const ptr;

   // This
   const char** buffer
   // is in fact:
   char const** buffer
   int main() {}
  #+end_src
   
** Right-to-left rule
   #+begin_src cpp 
   int n; // declare n as int
   int* p; // declare p as pointer to int;
    
   const int *p; // declare p as pointer to const int
   int const *p; // declares p as pointer to const int
   const char* const ptr; // declares ptr as const pointer to const char
   char const* const ptr; //declares ptr as const pointer to const *

   #+end_src

** Coroutines
 There are two kinds of interfaces that are defined by the coroutines
 TS. The Promise interface and the Awaitable interface.
*** Promise
  The Promise interface specifies methods for customising the behaviour
  of the coroutine itself. The library-writer is able to customise what
  happens when the coroutine is called, what happens when the coroutine
  returns (either by normal means or via an unhandled exception) and
  customise the behaviour of any ~co_await~ or ~co_yield~ expression
  within the coroutine.

  When you write a coroutine function that has a body,
  ~<body-statements>~, which contains one of the coroutine keywords
  (~co_return~, ~co_await~, ~co_yield~) then the body of the coroutine
  is transformed to something (roughly) like the following:
  #+begin_src cpp
    {
        co_await promise.initial_suspend();
        try
        {
    //<body-statements>
        }
        catch (...)
        {
            promise.unhandled_exception();
        }
    FinalSuspend:
        co_await promise.final_suspend();
    }
  #+end_src
  When a coroutine function is called there are a number of steps
  that are performed prior to executing the code in the source of the
  coroutine body that are a little different to regular functions.

  1) Allocate a coroutine frame using operator new (optional).
  2) Copy any function parameters to the coroutine frame.
  3) Call the constructor for the promise object of type, ~P~.
  4) Call the ~promise.get_return_object()~ method to obtain the result
     to return to the caller when the coroutine first suspends. Save
     the result as a local variable.
  5) Call the promise.initial_suspend() method and co_await the result.
  6) When the ~co_await promise.initial_suspend()~ expression resumes
     (either immediately or asynchronously), then the coroutine starts
     executing the coroutine body statements that you wrote.

  Some additional steps are executed when execution reaches a co_return statement:

  1) Call ~promise.return_void()~ or ~promise.return_value(<expr>)~
  2) Destroy all variables with automatic storage duration in reverse order they were created.
  3) Call ~promise.final_suspend()~ and ~co_await~ the result.

  If instead, execution leaves <body-statements> due to an unhandled exception then:

  1) Catch the exception and call ~promise.unhandled_exception()~ from
     within the catch-block.
  2) Call ~promise.final_suspend()~ and ~co_await~ the result.

  Once execution propagates outside of the coroutine body then the
  coroutine frame is destroyed. Destroying the coroutine frame involves
  a number of steps:

  1) Call the destructor of the promise object.
  2) Call the destructors of the function parameter copies.
  3) Call operator delete to free the memory used by the coroutine frame (optional)
  4) Transfer execution back to the caller/resumer.

  When execution first reaches a ~<return-to-caller-or-resumer>~ point
  inside a ~co_await~ expression, or if the coroutine runs to completion
  without hitting a ~<return-to-caller-or-resumer>~ point, then the
  coroutine is either suspended or destroyed and the return-object
  previously returned from the call to ~promise.get_return_object()~ is
  then returned to the caller of the coroutine.

*** Awaitable
 The Awaitable interface specifies methods that control the semantics
 of a ~co_await~ expression. When a value is co_awaited, the code is
 translated into a series of calls to methods on the awaitable object
 that allow it to specify: whether to suspend the current coroutine,
 execute some logic after it has suspended to schedule the coroutine
 for later resumption, and execute some logic after the coroutine
 resumes to produce the result of the ~co_await~ expression.

 The ~co_await~ operator is a new unary operator that can be applied
 to a value. For example: ~co_await~ someValue.

 The ~co_await~ operator can only be used within the context of a
 coroutine. This is somewhat of a tautology though, since any function
 body containing use of the ~co_await~ operator, by definition, will be
 compiled as a coroutine.

 A type that supports the ~co_await~ operator is called an ~Awaitable~
 type.

 An Awaiter type is a type that implements the three special methods
 that are called as part of a ~co_await~ expression: ~await_ready~,
 ~await_suspend~ and ~await_resume~.

**** Obtaining the Awaiter
 When the compiler sees a ~co_await <expr>~ expression there are
 actually a number of possible things it could be translated to
 depending on the types involved.

 The first thing the compiler does is generate code to obtain the
 Awaiter object for the awaited value. There are a number of steps to
 obtaining the awaiter object which are set out in N4680 section
 5.3.8(3).

 If the promise type, ~P~, has a member named ~await_transform~ then
 ~<expr>~ is first passed into a call to ~promise.await_transform(<expr>)~
 to obtain the Awaitable value, ~awaitable~. Otherwise, if the promise
 type does not have an ~await_transform~ member then we use the result
 of evaluating ~<expr>~ directly as the Awaitable object, ~awaitable~.

 Then, if the Awaitable object, ~awaitable~, has an applicable operator
 ~co_await()~ overload then this is called to obtain the Awaiter
 object. Otherwise the object, ~awaitable~, is used as the awaiter
 object.
 #+begin_src cpp
   template <typename P, typename T>
   decltype(auto) get_awaitable(P& promise, T&& expr)
   {
       if constexpr (has_any_await_transform_member_v<P>)
           return promise.await_transform(static_cast<T&&>(expr));
       else
           return static_cast<T&&>(expr);
   }

   template <typename Awaitable>
   decltype(auto) get_awaiter(Awaitable&& awaitable)
   {
       if constexpr (has_member_operator_co_await_v<Awaitable>)
           return static_cast<Awaitable&&>(awaitable).operator co_await();
       else if constexpr (has_non_member_operator_co_await_v<Awaitable&&>)
           return operator co_await(static_cast<Awaitable&&>(awaitable));
       else
           return static_cast<Awaitable&&>(awaitable);
   }
 #+end_src
 So, assuming we have encapsulated the logic for turning the ~<expr>~
 result into an Awaiter object into the above functions then the
 semantics of ~co_await <expr>~ can be translated (roughly) as
 follows:

 #+begin_src cpp
   {
       auto&& value = <expr>;
       auto&& awaitable =
           get_awaitable(promise, static_cast<decltype(value)>(value));
       auto&& awaiter = get_awaiter(static_cast<decltype(awaitable)>(awaitable));
       if (!awaiter.await_ready())
       {
           using handle_t = std::experimental::coroutine_handle<P>;

           using await_suspend_result_t =
               decltype(awaiter.await_suspend(handle_t::from_promise(p)));

           //<suspend-coroutine>

           if constexpr (std::is_void_v<await_suspend_result_t>)
           {
               awaiter.await_suspend(handle_t::from_promise(p));
               //<return-to-caller-or-resumer>
           }
           else
           {
               static_assert(std::is_same_v<await_suspend_result_t, bool>,
                   "await_suspend() must return 'void' or 'bool'.");

               if (awaiter.await_suspend(handle_t::from_promise(p)))
               {
                   //<return-to-caller-or-resumer>
               }
           }

           //   <resume-point>
       }
       return awaiter.await_resume();
   }
 #+end_src


* Compiler tricks
** Analyze Core dumps with mingw64
  + Register `UnhandledException` handler, which uses `dbghelp.lib` to
    write core dump

    #+begin_src cpp
      LONG WINAPI MyUnhandledExceptionFilter(EXCEPTION_POINTERS *ExceptionInfo) {
        std::cout << "Dump the core" << std::endl;
        HANDLE hFile =
            CreateFile(L"proc.dmp", GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                       CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        MINIDUMP_EXCEPTION_INFORMATION mei;
        mei.ThreadId = GetCurrentThreadId();
        mei.ClientPointers = TRUE;
        mei.ExceptionPointers = ExceptionInfo;
        MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), hFile,
                          MiniDumpNormal, &mei, NULL, NULL);

        return EXCEPTION_EXECUTE_HANDLER;
      }
      //  [...]
      int main() { SetUnhandledExceptionFilter(MyUnhandledExceptionFilter); }
    #+end_src
   + Compile with mingw64 and debug symbols
   + Convert dwarf debug symbolls to pdb with [[https://github.com/rainers/cv2pdb][cv2pdb.exe]]
     ~cv2pdb.exe test.exe~
   + Note: Make sure you use x64 bit version of `cv2pdb.exe` for x64bit core dumps
   + Load core dump in vs
* Tutorials
** Deconstructing function pointers in a C++ template
   + [[https://devblogs.microsoft.com/oldnewthing/20200713-00/?p=103978][Link]]
** Coroutine Tutorials
*** Lewis Baker
    + [[https://lewissbaker.github.io/2017/09/25/coroutine-theory][Part 1]]
    + [[https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await][Part 2]]
    + [[https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type][Part 3]]
*** By Raymond
    + [[https://devblogs.microsoft.com/oldnewthing/20191209-00/?p=103195][Part 1]]
    + [[https://devblogs.microsoft.com/oldnewthing/20191210-00/?p=103197][Part 2]]
    + [[https://devblogs.microsoft.com/oldnewthing/20191211-00/?p=103201][Part 3]]
    + [[https://devblogs.microsoft.com/oldnewthing/20191212-00/?p=103207][Part 4]]
    + [[https://devblogs.microsoft.com/oldnewthing/20191213-00/?p=103210][Part 5]]
    + [[https://devblogs.microsoft.com/oldnewthing/20191216-00/?p=103217][Part 6]]
    + [[https://devblogs.microsoft.com/oldnewthing/20191217-00/?p=103219][Part 7]]
    + [[https://devblogs.microsoft.com/oldnewthing/20191218-00/?p=103221][Part 8]]
*** What are coroutines?
   + Tutorial Lewis Baker (see https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await)
   + Coroutines are functions which can be suspended and resumed. In
     c++ a coroutine is a function which has one of the follwoing
     keywords: ~co_return~, ~co_yield~, ~co_await~
   + There are two kinds of interfaces that are defined by the
     coroutines TS: The *Promise* interface and the *Awaitable*
     interface.
     + The *Promise* interface specifies methods for customising the
       behaviour of the coroutine itself. The library-writer is able
       to customise what happens when the coroutine is called, what
       happens when the coroutine returns (either by normal means or
       via an unhandled exception) and customise the behaviour of any
       co_await or co_yield expression within the coroutine.
     + The *Awaitable* interface specifies methods that control thea
       semantics of a co_await expression. When a value is co_awaited,
       the code is translated into a series of calls to methods on the
       awaitable object that allow it to specify: whether to suspend
       the current coroutine, execute some logic after it has
       suspended to schedule the coroutine for later resumption, and
       execute some logic after the coroutine resumes to produce the
       result of the co_await expression.
   + *Awaitable* types
     + Operator ~co_await~
       + A type that supports the co_await operator is called an
         Awaitable type.
       + Note that whether or not the co_await operator can be applied
         to a type can depend on the context in which the co_await
         expression appears. The promise type used for a coroutine can
         alter the meaning of a co_await expression within the coroutine
         via its ~await_transform~ method (more on this later).
       + An Awaiter type is a type that implements the three special
         methods that are called as part of a co_await expression:
         ~await_ready~, ~await_suspend~ and ~await_resume~.
       + If the promise type, ~P~ has a member named ~await_transform~
         then <expr> is first passed into a call to
         ~promise.await_transform(<expr>)~ to obtain the ~Awaitable~
         value, ~awaitable~. Otherwise, if the promise type does not
         have an ~await_transform~ member then we use the result of
         evaluating ~<expr>~ directly as the ~Awaitable~ object,
         ~awaitable~. Then, if the ~Awaitable~ object, ~awaitable~, has
         an applicable ~operator co_await()~ overload then this is
         called to obtain the Awaiter object. Otherwise the object,
         ~awaitable~, is used as the awaiter object.
       + Rules above as source:
         #+begin_src cpp
           template <typename P, typename T>
           decltype(auto) get_awaitable(P& promise, T&& expr)
           {
               if constexpr (has_any_await_transform_member_v<P>)
                   return promise.await_transform(static_cast<T&&>(expr));
               else
                   return static_cast<T&&>(expr);
           }

           template <typename Awaitable>
           decltype(auto) get_awaiter(Awaitable&& awaitable)
           {
               if constexpr (has_member_operator_co_await_v<Awaitable>)
                   return static_cast<Awaitable&&>(awaitable).operator co_await();
               else if constexpr (has_non_member_operator_co_await_v<Awaitable&&>)
                   return operator co_await(static_cast<Awaitable&&>(awaitable));
               else
                   return static_cast<Awaitable&&>(awaitable);
           }

           // Assumging the logic for turning the <expr> result into an Awaiter
           // object is encapsulated in the functions above, the semantics of the
           // co_await <expr> can be translated into this:

           {
               auto&& value = <expr>;
               auto&& awaitable =
                   get_awaitable(promise, static_cast<decltype(value)>(value));
               auto&& awaiter = get_awaiter(static_cast<decltype(awaitable)>(awaitable));

               // The purpose of the await_ready() method is to allow you to
               // avoid the cost of the <suspend-coroutine> operation in cases
               // where it is known that the operation will complete
               // synchronously without needing to suspend.
               if (!awaiter.await_ready())
               {
                   using handle_t = std::experimental::coroutine_handle<P>;

                   using await_suspend_result_t =
                       decltype(awaiter.await_suspend(handle_t::from_promise(p)));

                   // At the <suspend-coroutine> point the compiler generates some
                   // code to save the current state of the coroutine and prepare
                   // it for resumption. This includes storing the location of the
                   //<resume-point> as well as spilling any values currently held
                   // in registers into the coroutine frame memory.

                   //<suspend-coroutine>

                   // The current coroutine is considered suspended after the
                   //<suspend-coroutine> operation completes. The first point at
                   // which you can observe the suspended coroutine is inside the
                   // call to await_suspend(). Once the coroutine is suspended it
                   // is then able to be resumed or destroyed.

                   // It is the responsibility of the await_suspend() method to
                   // schedule the coroutine for resumption (or destruction) at
                   // some point in the future once the operation has
                   // completed.
                   if constexpr (std::is_void_v<await_suspend_result_t>)
                   {
                       // The void-returning version of await_suspend()
                       // unconditionally transfers execution back to the
                       // caller/resumer of the coroutine when the call to
                       // await_suspend() returns
                       awaiter.await_suspend(handle_t::from_promise(p));

                       // At the <return-to-caller-or-resumer> point execution is
                       //transferred back to the caller or resumer, popping the
                       //local stack frame but keeping the coroutine frame alive.

                       //<return-to-caller-or-resumer>
                   }
                   else
                   {
                       // the bool-returning version allows the awaiter object to
                       // conditionally resume the coroutine immediately without
                       // returning to the caller/resumer. Can be useful in cases
                       // where the awaiter might start an async operation that
                       // can sometimes complete synchronously. In the cases where
                       // it completes synchronously, the await_suspend() method
                       // can return false to indicate that the coroutine should
                       // be immediately resumed and continue execution.

                       // Note that returning false from await_suspend() counts as
                       // scheduling the coroutine for immediate resumption on the current
                       // thread.
                       static_assert(std::is_same_v<await_suspend_result_t, bool>,
                           "await_suspend() must return 'void' or 'bool'.");

                       if (awaiter.await_suspend(handle_t::from_promise(p)))
                       {
                           // At the <return-to-caller-or-resumer> point
                           // execution is transferred back to the caller or
                           // resumer, popping the local stack frame but keeping
                           // the coroutine frame alive.

                           //<return-to-caller-or-resumer>
                       }
                   }

                   // When (or if) the suspended coroutine is eventually resumed
                   // then the execution resumes at the
                   // <resume-point>. ie. immediately before the await_resume()
                   // method is called to obtain the result of the operation.

                   //<resume-point>
               }

               // The return-value of the await_resume() method call becomes the
               // result of the co_await expression. The await_resume() method
               // can also throw an exception in which case the exception
               // propagates out of the co_await expression.
               return awaiter.await_resume();
           }
         #+end_src
     + Coroutine handle:
       + Represents a non-owning handle to the coroutine frame and can
         be used to resume execution of the coroutine or to destroy the
         coroutine frame. It can also be used to get access to the
         coroutine’s promise object.
       + Interface of the handle type looks like this:
         #+begin_src cpp
           namespace std::experimental
           {
           template <typename Promise>
           struct coroutine_handle;

           template <>
           struct coroutine_handle<void>
           {
               bool done() const;

               // Calling .resume() on a handle will reactivate a suspended
               // coroutine at the <resume-point>. The call to .resume() will
               // return when the coroutine next hits a
               // <return-to-caller-or-resumer> point.
               void resume();

               //The .destroy() method destroys the coroutine frame, calling the
               //destructors of any in-scope variables and freeing memory used by
               //the coroutine frame. Should normally be managed by RAII type and
               //not called manually.
               void destroy();

               void* address() const;
               static coroutine_handle from_address(void* address);
           };

           template <typename Promise>
           struct coroutine_handle : coroutine_handle<void>
           {
               //The .promise() method returns a reference to the coroutine’s
               //promise object. However, like .destroy(), it is generally only
               //useful if you are authoring coroutine promise types. You should
               //consider the coroutine’s promise object as an internal
               //implementation detail of the coroutine. For most Normally
               //Awaitable types you should use coroutine_handle<void> as the
               //parameter type to the await_suspend() method instead of
               //coroutine_handle<Promise>.
               Promise& promise() const;

               //The coroutine_handle<P>::from_promise(P& promise) function
               //allows reconstructing the coroutine handle from a reference to
               //the coroutine’s promise object. Note that you must ensure that
               //the type, P, exactly matches the concrete promise type used for
               //the coroutine frame; attempting to construct a
               //coroutine_handle<Base> when the concrete promise type is Derived
               //can lead to undefined behaviour.
               static coroutine_handle from_promise(Promise& promise);

               // The .address() / from_address() functions allow converting a
               // coroutine handle to/from a void* pointer. This is primarily
               // intended to allow passing as a ‘context’ parameter into
               // existing C-style APIs, so you might find it useful in
               // implementing Awaitable types in some circumstances. However, in
               // most cases I’ve found it necessary to pass additional
               // information through to callbacks in this ‘context’ parameter so
               // I generally end up storing the coroutine_handle in a struct and
               // passing a pointer to the struct in the ‘context’ parameter
               // rather than using the .address() return-value.
               static coroutine_handle from_address(void* address);
           };
           } // namespace std::experimental
         #+end_src
     + Synchronisation free async code
       + One of the powerful design-features of the co_await operator is
         the ability to execute code after the coroutine has been
         suspended but before execution is returned to the
         caller/resumer.
       + This allows an Awaiter object to initiate an async operation
         after the coroutine is already suspended, passing the
         coroutine_handle of the suspended coroutine to the operation
         which it can safely resume when the operation completes
         (potentially on another thread) without any additional
         synchronisation required.
       + *Carefull*: If the coroutine is passed to another thread it
         might be resumed *before* the ~await_suspend~ returns. The
         first thing the coroutine will do when it resumes is call
         ~await_resume~ to get the result and destruct the awaiter
         object (this pointer of the ~await_suspend~). So within the
         ~await_suspend~ method, once it is possible for the coroutine
         to be resumed concurrently on another thread, you need to make
         sure that you avoid accessing ~this~ or the coroutines
         ~.promise()~ object because both could already be destroyed. In
         general, the only things that are safe to access after the
         operation is started and the coroutine is scheduled for
         resumption are local variables within ~await_suspend()~.
   + *Promise* types
     + The *Promise* object defines and controls the behaviour of the
       coroutine itself by implementing methods that are called at
       specific points during execution of the coroutine.

     + When you write a coroutine function that has a body,
       <body-statements>, which contains one of the coroutine keywords
       (co_return, co_await, co_yield) then the body of the coroutine
       is transformed to something (roughly) like the following:

       #+begin_src cpp
         {
             co_await promise.initial_suspend();
             try
             {
                 //<body-statements>
             }
             catch (...)
             {
                 promise.unhandled_exception();
             }
         FinalSuspend:
             co_await promise.final_suspend();
         }
       #+end_src

       When a coroutine function is called there are a number of steps
       that are performed prior to executing the code in the source of
       the coroutine body that are a little different to regular
       functions.

       Here is a summary of the steps 

       1) Allocate a coroutine frame using operator new (optional).
       2) Copy any function parameters to the coroutine frame.
       3) Call the constructor for the promise object of type, P.
       4) Call the promise.get_return_object() method to obtain the
          result to return to the caller when the coroutine first
          suspends. Save the result as a local variable.
       5) Call the ~promise.initial_suspend()~ method and co_await the
          result.
       6) When the co_await promise.initial_suspend() expression
         resumes (either immediately or asynchronously), then the
         coroutine starts executing the coroutine body statements that
         you wrote.

       Some additional steps are executed when execution reaches a
       co_return statement:

     + Call ~promise.return_void()~ or ~promise.return_value(<expr>)~
       1) Destroy all variables with automatic storage duration in
          reverse order they were created.
       2) Call ~promise.final_suspend()~ and co_await the result
   + Notes:
     + Note that it is undefined behaviour to resume() a coroutine
       that is suspended at the final_suspend point. The only thing
       you can do with a coroutine suspended here is destroy() it.
     + What happens if a coroutine is called on a task
       object. Consider this
       #+begin_src cpp
         task foo()
         {
             co_return;
         }

         task bar()
         {
             co_await foo();
         }
       #+end_src
       1) Bar coroutine calls functin foo (from caller's perspective a
          coroutine is just an normal function call).
       2) The invocation of ~foo()~, the coroutine, performs the
          following steps:
          1) Allocate storage for a coroutine frame
          2) Copies parameters into the coroutine frame
          3) Constructs the promise object in the coroutine frame
          4) Calls ~promise.get_return_object()~ to get the
             return-value for ~foo()~. This produces the ~task~ object
             that will be returned, initialising it with a
             ~std::coroutine_handle~ that refers to the coroutine
             frame that was just created.
          5) Suspends the exectuion of the coroutine (in case
             ~initial_suspend~ returns ~std::always_suspend~) at the
             initial suspend point (i.e the open curly brace).
          6) Returns the task object to ~bar()~
       3) The ~bar()~ coroutine evaluates the ~co_await~ expression on
          the ~task~ object returned from ~foo~.
          1) The ~bar()~ coroutine suspends and then calls the
             ~await_suspend()~ method on the returned task, passing it
             the ~std::coroutine_handle~ that refers to the ~bar()~'s
             coroutine frame.
          2) The ~await_suspend~ method stores ~bars~ coroutine handle
             in ~foo()~ promise object and then resumes the ~foo~
             coroutine by calling ~.resume~ on ~foo()~
             ~std::coroutine_handle~.
       4) The ~foo~ coroutine executes and runs to completion
          synchronously.
       5) The ~foo~ suspends at the final suspend point (if specified
          by the promise) which is the closing curly brace. The
          ~std::coroutine_handle~ that was stored in ~foo()~ promise
          type (~bars~ coroutine) when it was started is resumed.
       6) The ~bar~ coroutine resumes and continues executing until it
          reaches the end of the ~co_await~ expression at which point
          the destructor of the temporary task object that was
          returned by ~foo~ is called.
       7) The ~task~ destructor then calls the ~.destroy()~ method on
          ~foo()~ coroutine handle which destorys the coroutine frame
          along with the promise object and the copies of the
          arguments.

*** More explanations from different tutorials

   + The compiler replaces the function body of the coroutine into
     something like this if we only use ~co_await~
     #+begin_src cpp
       Task<int> foo()
       {
           co_return 43;
       }
       // into

       Task<int> foo
       {
           // Definition of the coroutine frame
           struct CoroutineFrame
           {
               Task<int>::promise_type promise;
               bool initial_await_resume_called = false;
               int state = 0;
               void operator()()
               {
                   try
                   {
                       co_await promise.initial_suspend();
                       // function_body; co_return value is transformed into
                       // promise.return_value(value) or to
                       // promise.return_void() if value is void.
                       promise.return_value(42);
                       goto final_suspend;
                   }
                   catch (...)
                   {
                       // If coroutine fail to initialize we throw exception
                       if (!initial_await_resume_called)
                           throw;
                       // If exception happens inside the body, catch it here
                       // and call ~unhandled_exception~ on the promise type.
                       promise.unhandled_exception();
                   }
               final_suspend:
                   co_await promise.final_suspend();
               }
           };
           // Allocate the coroutine frame
           auto coroutineFrame = new CoroutineFrame;
           auto returnObject{coroutineFrame->promise.get_return_object()};
           (*coroFrame)();
           return returnObject;
       }
     #+end_src
   + The expression ~co_await result;~ is transformed into:
     #+begin_src cpp
       auto awaitable{getAwaitable(result)};
       if (!awaitable.await_ready())
       {
           awaitable.await_suspend(thisCoroHandle);
           // suspend coroutine
       }
       resume : awaitable.await_resume();
     #+end_src

